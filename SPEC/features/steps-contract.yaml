# Canonical step vocabulary for Switchyard features
# Simple contract: each entry provides a regex pattern the step must match.
# The validator will ensure all steps in .feature files match at least one pattern here.

steps:
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) /.+ is a symlink to .+$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) the target and staging directories reside on different filesystems$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a plan with three actions \w+, \w+, \w+$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a plan with at least one action$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) action \w+ will fail during apply$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) the minimal post-apply smoke suite is configured$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a production deployment with a LockManager$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) another apply\(\) is already holding the lock$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a development environment without a LockManager$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a configured rescue profile consisting of backup symlinks$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) at least one fallback binary set \(GNU or BusyBox\) is installed and on PATH$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a plan that mutates a file$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a plan with environment-derived values that may be sensitive$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a plan that uses an external helper$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a mutating public API endpoint$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a mutation of a final path component under a parent directory$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) at least one smoke command will fail with a non-zero exit$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) no explicit approval flag is provided$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a critical compatibility violation is detected in preflight$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) golden fixtures for plan, preflight, apply, and rollback$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a required test is marked SKIP or a fixture diff is not byte-identical$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) normalized plan input and a stable namespace$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) an apply bundle$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a rename completes for a staged swap$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a candidate path containing .. segments or symlink escapes$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) the target filesystem is read-only or noexec or immutable$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a source file that is not root-owned or is world-writable$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) strict_ownership=true policy$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) a target that is not package-owned per the ownership oracle$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) the policy requires preserving owner, mode, timestamps, xattrs, ACLs, and caps$
  - kind: Given
    pattern: ^(?:Given|When|Then|And|But) the filesystem or environment lacks support for one or more of these$

  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I plan a swap to \S+$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I apply the plan$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I run in dry-run mode$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I run in real mode$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I apply a plan$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I run preflight$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I attempt to apply a plan$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) two apply\(\) calls overlap in time$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I apply a plan that replaces /.+$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I inspect its signature$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) the engine performs the operation$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I run the engine$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I run the engine with default policy$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) CI runs$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I generate plan_id and action_id$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I complete an apply$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) the engine performs fsync on the parent directory$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I attempt to construct a SafePath$
  - kind: When
    pattern: ^(?:Given|When|Then|And|But) I attempt to apply a plan$

  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) /.+ resolves to .+ atomically$
    
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) rollback restores .+$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the operation handles EXDEV by copy\+sync\+rename into place atomically$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the engine automatically rolls back \w+ in reverse order$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) every stage emits a JSON fact that validates against /SPEC/audit_event.schema.json$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the emitted facts for plan and preflight are byte-identical after timestamp redaction$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the emitted facts for apply\.result per-action events are byte-identical after redaction$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the resulting facts include hash_alg=sha256 and both before_hash and after_hash$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) no unmasked secret values appear in any emitted fact or log sink$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) facts include origin, helper, uid, gid, pkg, and env_sanitized=true$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) lock acquisition uses a bounded wait and times out with E_LOCKING when exceeded$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the failure is emitted with error_id=E_LOCKING and exit_code=30$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) concurrent apply is UNSUPPORTED and a WARN fact is emitted$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) preflight verifies a functional fallback path$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) a rescue profile remains available for recovery$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the smoke suite runs and detects the failure$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) automatic rollback occurs unless policy explicitly disables it$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) facts record degraded=true when policy allow_degraded_fs is enabled$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the operation uses a best-effort degraded fallback for symlink replacement \(unlink \+ symlink\) when EXDEV occurs$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the operation fails with error_id=E_EXDEV when allow_degraded_fs is disabled$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) each fact carries schema_version=1$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) facts clearly indicate partial restoration state if any rollback step fails$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) facts record lock_wait_ms$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) facts record lock_wait_ms when available$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) at least one smoke command will fail with a non-zero exit$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the signature requires SafePath and does not accept PathBuf$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) it opens the parent with O_DIRECTORY\|O_NOFOLLOW, uses openat on the final component, renames with renameat, and fsyncs the parent$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) it runs in dry-run mode by default$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the operation fails closed unless an explicit override is present$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the CI job fails$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) they are UUIDv5 values derived from the normalized input and namespace$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) an attestation is generated and signed with ed25519 and attached to the facts$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) an attestation is attached to the apply\.result summary fact with sig_alg=ed25519, signature, bundle_hash, and public_key_id$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) the fsync occurs within 50ms of the rename and is recorded in telemetry$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) if the fsync duration exceeds 50ms the fact is recorded with severity=warn$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) SafePath normalization rejects the path as unsafe$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) operations fail closed with a policy violation error$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) preflight fails closed unless an explicit policy override is present$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) preflight fails closed$
  - kind: Then
    pattern: ^(?:Given|When|Then|And|But) preflight stops with a fail-closed decision unless an explicit override is set$
