# Backups and Restore in Switchyard

This document explains precisely how Switchyard creates backups (snapshots) and performs restore operations. It references the exact functions and paths in the codebase for clarity.

- Filesystem backup/sidecar logic: `cargo/switchyard/src/fs/backup.rs`
- Filesystem restore logic: `cargo/switchyard/src/fs/restore.rs`
- Symlink swap orchestration (calls backup): `cargo/switchyard/src/fs/swap.rs`
- API-layer restore handler: `cargo/switchyard/src/api/apply/handlers.rs`
- Preflight stage (backup presence annotation): `cargo/switchyard/src/api/preflight.rs`

## Goals and model

- Preserve the previous state of a target path before mutating it (file, symlink, or absence).
- Store a backup payload and a machine-readable sidecar describing prior state.
- Restore should be idempotent and safe, using TOCTOU-safe syscalls and `fsync` to ensure persistence.
- Backups live alongside the target, are timestamped, and are grouped by a `backup_tag` to separate domains.

## Backup artifacts (what gets created)

When a snapshot is taken (see `create_snapshot()`), Switchyard produces two artifacts next to the target:

1) Backup payload

- File topology: a regular file containing the bytes of the original target, at a timestamped name.
- Symlink topology: a symlink backup that points to the original target's destination.
- None topology: a tombstone payload (an empty file) marking that the original target did not exist.

2) Sidecar (`.meta.json`)

- JSON sidecar describing the prior state and attributes.
- Schema struct: `BackupSidecar` in `fs/backup.rs` with fields:
  - `schema`: string, e.g. "backup_meta.v1".
  - `prior_kind`: one of `"file" | "symlink" | "none"`.
  - `prior_dest`: optional string for symlinks (the destination that was previously in place).
  - `mode`: optional octal string preserving file mode for file topology.

### Naming and location

- Both artifacts live in the same directory as the target.
- Base filename pattern:
  - `.{name}.{tag}.{timestamp}.bak` (payload)
  - `.{name}.{tag}.{timestamp}.bak.meta.json` (sidecar)
- Generated by `backup_path_with_tag(target, tag) -> PathBuf` and `sidecar_path_for_backup(backup) -> PathBuf`.
- Timestamp is in milliseconds since UNIX epoch.

## When are backups created?

Backups are created by `create_snapshot()` and are invoked automatically before mutations.

- Primary caller: `fs/swap.rs::replace_file_with_symlink(source, target, dry_run, allow_degraded, backup_tag)`.
  - Before replacing `target` with a symlink to `source`, it snapshots the current state using `create_snapshot(target, backup_tag)`.
  - This is done for both cases where the target currently is:
    - a regular file, or
    - a symlink (recording the current symlink destination), or
    - absent (creating a tombstone to record that it didn't exist).

## How backup creation works (create_snapshot)

Function: `fs/backup.rs::create_snapshot(target, backup_tag) -> io::Result<()>`

- Detect current topology using `std::fs::symlink_metadata`.
- Branch by topology:
  - Prior is a symlink:
    - Read the current destination with `read_link`.
    - Create a symlink backup pointing to the same destination (so it is self-describing even without the sidecar).
    - Write sidecar with `prior_kind = "symlink"` and `prior_dest = <dest>`.
  - Prior is a regular file:
    - Open the parent directory with `open_dir_nofollow` to get a capability handle.
    - Open the source (`target`) with `openat(RDONLY)` and the destination (backup) with `openat(WRONLY|CREATE|TRUNC, 0o600)`.
    - Stream-copy bytes using OS file descriptors to avoid TOCTOU races.
    - Apply original permissions to the backup via `fchmod` using the source metadata's mode.
    - Write sidecar with `prior_kind = "file"` and `mode = <octal perms>`.
  - Prior is absent (target missing):
    - Create an empty backup payload file.
    - Write sidecar with `prior_kind = "none"`.
- Sidecar writing uses `write_sidecar()` which ensures the parent directory exists and serializes JSON prettily.

Safety measures:

- `open_dir_nofollow(parent)` + `openat(...)` avoids symlink traversal TOCTOU issues.
- `unlinkat`/`renameat` sequences are used as needed to avoid races in restore/swap.
- `fsync_parent_dir(target)` is used during restore to persist directory updates.

## How restore works

Two public restore functions exist:

- `fs/restore.rs::restore_file(target, dry_run, force_best_effort, backup_tag)`
- `fs/restore.rs::restore_file_prev(target, dry_run, force_best_effort, backup_tag)`

Both functions follow the same high-level flow, differing only in which backup pair they select:

1) Locate backup artifacts

- Latest pair: `find_latest_backup_and_sidecar(target, tag)`.
- Previous pair (second newest): `find_previous_backup_and_sidecar(target, tag)`.
- Each returns `(Option<payload_path>, sidecar_path)`:
  - `payload_path` may be `None` (e.g., it was deleted or only sidecar remains).
  - `sidecar_path` is always returned (it may or may not exist on disk).

2) Read sidecar (if present)

- `read_sidecar()` attempts to parse the sidecar JSON.
- If missing, restore falls back to legacy behavior when a payload is present (rename payload to target).

3) Idempotence check

- If sidecar is present, and the current state already matches `prior_kind`, restore is a no-op and returns `Ok(())`.
  - `prior_kind = "file"`: target is already a regular file.
  - `prior_kind = "none"`: target is already absent.
  - `prior_kind = "symlink"`: target is a symlink and its destination matches `prior_dest` (comparison uses canonicalized forms; relative paths are joined to the target's parent before canonicalization for robustness).

4) Dry-run short-circuit

- If `dry_run` is true, return `Ok(())` after idempotence checks.

5) Apply the restore per `prior_kind`

- `file` prior:
  - Require a payload; error with `NotFound` unless `force_best_effort` is true.
  - `renameat` the payload to the original target filename (within the same parent directory capability).
  - If `mode` present in sidecar, reopen the restored target and `fchmod` to that mode.
  - `fsync_parent_dir(target)` for durability.

- `symlink` prior:
  - If `prior_dest` present, use `atomic_symlink_swap(prior_dest, target, allow_degraded = true)` to restore symlink topology safely, then `fsync_parent_dir(target)`.
  - Remove the payload if present (sidecar remains).
  - If `prior_dest` missing, fall back to renaming the payload if available; otherwise error unless `force_best_effort`.

- `none` prior:
  - Ensure the path is absent: open parent and `unlinkat` the entry if it exists, or `remove_file(target)` as fallback; then `fsync_parent_dir(target)`.
  - Remove payload if present.

- Unknown `prior_kind`:
  - Legacy rename fallback if payload exists; else `NotFound` unless `force_best_effort`.

6) No sidecar fallback

- If there is no sidecar but a payload exists, the restore renames the payload back to the target name.

### Previous vs latest restore

- `restore_file_prev()` is intended for workflows where a fresh snapshot was taken just before restore, and you want the state *before* that snapshot.
- The API layer can capture such a snapshot and then call `restore_file_prev()`; if the "previous" pair does not exist, the API handler falls back to the latest pair.

## API-layer orchestration of restore

Function: `api/apply/handlers.rs::handle_restore(api, tctx, pid, act, idx, dry)`

- Optionally takes a fresh snapshot when `policy.capture_restore_snapshot` is true. This causes the subsequent restore to prefer the "previous" pair.
- Calls `restore_file_prev()` if a snapshot was just captured; otherwise calls `restore_file()`.
- If `restore_file_prev()` returns `NotFound`, it falls back to `restore_file()`.
- Emits structured audit facts, including before/after kinds and standard error IDs:
  - `E_BACKUP_MISSING` when artifacts cannot be found.
  - `E_RESTORE_FAILED` for other I/O errors.

## Preflight stage and backup presence

Function: `api/preflight.rs::run(...)`

- For `Action::RestoreFromBackup`, preflight uses `fs::has_backup_artifacts(target, backup_tag)` to annotate whether artifacts are present.
- If policy requires a rescue profile and artifacts are missing, preflight may STOP with a policy failure.

## Policy knobs and configuration

- `backup_tag` (string): included in every backup name; separates domains (e.g., different experiments).
- `force_restore_best_effort` (bool): allow restore to succeed as a no-op when required artifacts are missing.
- `capture_restore_snapshot` (bool): take a fresh snapshot before a restore, so the restore targets the previous state.
- `allow_degraded_fs` (bool): influences symlink swap behavior (EXDEV fallback), not the backup creation itself.

## Clean-up semantics during restore

- When restoring `symlink` or `none` prior states, the restore removes the backup payload if present; the sidecar is left in place for auditability.
- When restoring `file` prior, the payload becomes the target via `renameat`, so the payload path no longer exists after success.

## Safety and correctness considerations

- TOCTOU-safe sequences using `open_dir_nofollow`, `openat`, `renameat`, `unlinkat` (see `fs/atomic.rs`).
- `fsync_parent_dir(target)` to ensure directory updates hit disk.
- Idempotence guard based on sidecar and actual current state to make repeated restores safe.
- `is_safe_path()` checks in `replace_file_with_symlink()` ensure only safe filesystem roots are mutated.

## Example sequence: replace then restore

1) Before

- `target` is a regular file with content.

2) Apply

- `replace_file_with_symlink(source, target, ...)` is called.
- It calls `create_snapshot(target, tag)`:
  - Creates `.target.<tag>.<ts>.bak` and `.target.<tag>.<ts>.bak.meta.json` with `prior_kind = "file"` and `mode`.
- It atomically swaps `target` to a symlink pointing to `source`.

3) Restore

- `restore_file(target, ...)` is called later.
- It finds the latest backup pair, reads sidecar, and performs restore:
  - Renames payload to `target`, applies `mode`, `fsync`s.

## Quick reference (functions)

- Backups
  - `fs::backup::create_snapshot()` — creates payload + sidecar for file/symlink/none.
  - `fs::backup::backup_path_with_tag()`, `sidecar_path_for_backup()` — names.
  - `fs::backup::find_latest_backup_and_sidecar()`, `find_previous_backup_and_sidecar()` — discovery.
  - `fs::backup::write_sidecar()`, `read_sidecar()` — metadata I/O.

- Restore
  - `fs::restore::restore_file()` — restore from latest pair.
  - `fs::restore::restore_file_prev()` — restore from previous pair.

- Integration
  - `fs::swap::replace_file_with_symlink()` — triggers snapshot before mutation.
  - `api::apply::handlers::handle_restore()` — orchestrates restore at the API layer.
  - `api::preflight::run()` — annotates presence of artifacts in preflight rows.

## Notes on timestamps and testing

- Backup names include a millisecond timestamp from `SystemTime::now()`; this makes names non-deterministic.
- Tests should avoid asserting on exact names and instead query using `find_latest_backup_and_sidecar()`.
- If stronger determinism is desired, consider introducing a clock abstraction (see design notes in `FS_BACKUP_RESTORE_AUDIT.md`).
