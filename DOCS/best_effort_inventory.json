[
  {
    "id": "cargo/switchyard/src/fs/atomic.rs:74-79",
    "repo_path": "cargo/switchyard/src/fs/atomic.rs",
    "start_line": 74,
    "end_line": 79,
    "language": "rust",
    "detection": {"type": "both", "triggers": ["comment: Best-effort unlink", "let _ = unlinkat(...)"]},
    "snippet": "// Best-effort unlink temporary name if present (ignore errors)\nlet tmp_c = std::ffi::CString::new(tmp_name.as_str())\n    .map_err(|_| std::io::Error::new(std::io::ErrorKind::InvalidInput, \"invalid cstring\"))?;\nlet _ = unlinkat(&dirfd, tmp_c.as_c_str(), AtFlags::empty());",
    "why_best_effort": "Temporary cleanup is attempted and errors are intentionally ignored to avoid failing the main atomic swap path.",
    "effort_dimensions": {
      "error_handling": "nonfatal",
      "guarantee_level": "weak",
      "fallback_behavior": "none",
      "preconditions": "none",
      "platform_coverage": "posix_only",
      "dependency_footprint": "minimal_extra",
      "observability": "none",
      "determinism": "deterministic_when_supported",
      "data_integrity": "fsync/durability",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Leftover temp entries may accumulate if unlink fails.",
    "improvement_hooks": ["log unlink failure at debug level", "collect metrics for leftover temps"],
    "related_tests": ["cargo/switchyard/tests/requirements/atomic_crash_safety.rs"],
    "owner_guess": "fs::atomic"
  },
  {
    "id": "cargo/switchyard/src/fs/atomic.rs:95-108",
    "repo_path": "cargo/switchyard/src/fs/atomic.rs",
    "start_line": 95,
    "end_line": 108,
    "language": "rust",
    "detection": {"type": "both", "triggers": ["Err(XDEV) => fallback", "let _ = fsync_parent_dir(...) ", "comment: best-effort non-atomic replacement"]},
    "snippet": "match renameat(&dirfd, tmp_c2.as_c_str(), &dirfd, new_c.as_c_str()) {\n    Ok(()) => {\n        let _ = fsync_parent_dir(target);\n        let fsync_ms = u64::try_from(t0.elapsed().as_millis()).unwrap_or(u64::MAX);\n        Ok((false, fsync_ms))\n    }\n    Err(e) if e == Errno::XDEV && allow_degraded => {\n        // Fall back: best-effort non-atomic replacement\n        let _ = unlinkat(&dirfd, new_c.as_c_str(), AtFlags::empty());\n        symlinkat(src_c.as_c_str(), &dirfd, new_c.as_c_str()).map_err(errno_to_io)?;\n        let _ = fsync_parent_dir(target);\n        let fsync_ms = u64::try_from(t0.elapsed().as_millis()).unwrap_or(u64::MAX);\n        Ok((true, fsync_ms))\n    }",
    "why_best_effort": "On cross-filesystem rename failure (EXDEV), behavior downgrades to a non-atomic create; fsync attempts are non-fatal.",
    "effort_dimensions": {
      "error_handling": "fallback",
      "guarantee_level": "conditional",
      "fallback_behavior": "degrade_quality",
      "preconditions": "requires_feature",
      "platform_coverage": "posix_only",
      "dependency_footprint": "minimal_extra",
      "observability": "structured_logs",
      "determinism": "best_effort_ordering",
      "data_integrity": "fsync/durability",
      "safety_surface": "has_rollback"
    },
    "risk_notes": "Non-atomic fallback can expose transient states to concurrent readers.",
    "improvement_hooks": ["gate degraded fallback by policy flag", "promote failure when durability policy is strict"],
    "related_tests": ["cargo/switchyard/tests/apply/exdev_degraded.rs"],
    "owner_guess": "fs::atomic"
  },
  {
    "id": "cargo/switchyard/src/fs/swap.rs:70-83",
    "repo_path": "cargo/switchyard/src/fs/swap.rs",
    "start_line": 70,
    "end_line": 83,
    "language": "rust",
    "detection": {"type": "code_pattern", "triggers": ["let _ = unlinkat(...)", "layered attempts"]},
    "snippet": "// Atomically swap: ensure target removed via cap-handle\nif let Some(parent) = target_path.parent() {\n    let dirfd = open_dir_nofollow(parent)?;\n    let fname = target_path.file_name().and_then(|s| s.to_str()).unwrap_or(\"target\");\n    let fname_c = std::ffi::CString::new(fname)...?;\n    let _ = unlinkat(&dirfd, fname_c.as_c_str(), AtFlags::empty());\n}\nlet res = atomic_symlink_swap(&source_path, &target_path, allow_degraded)?;",
    "why_best_effort": "Pre-removal of the target ignores unlink errors to proceed with the swap path.",
    "effort_dimensions": {
      "error_handling": "nonfatal",
      "guarantee_level": "weak",
      "fallback_behavior": "none",
      "preconditions": "none",
      "platform_coverage": "posix_only",
      "dependency_footprint": "minimal_extra",
      "observability": "none",
      "determinism": "deterministic_when_supported",
      "data_integrity": "fsync/durability",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Leftover targets could cause rename failure if permissions prevent unlink.",
    "improvement_hooks": ["log unlink failure at debug level"],
    "related_tests": ["cargo/switchyard/tests/oracles/ensure_symlink_success.rs"],
    "owner_guess": "fs::swap"
  },
  {
    "id": "cargo/switchyard/src/fs/backup/snapshot.rs:46-63",
    "repo_path": "cargo/switchyard/src/fs/backup/snapshot.rs",
    "start_line": 46,
    "end_line": 63,
    "language": "rust",
    "detection": {"type": "both", "triggers": ["remove_file ignored", "symlink ignored", "comment: Durability best-effort", "let _ = fsync_parent_dir"]},
    "snippet": "if let Some(curr) = current_dest.as_ref() {\n    let backup = backup_path_with_tag(target, backup_tag);\n    let _ = fs::remove_file(&backup);\n    let _ = unix::fs::symlink(curr, &backup);\n    // Durability: best-effort parent fsync\n    let _ = crate::fs::atomic::fsync_parent_dir(target);\n}",
    "why_best_effort": "Backup creation for symlinks tolerates failures in cleanup, symlink creation, and fsync.",
    "effort_dimensions": {
      "error_handling": "nonfatal",
      "guarantee_level": "weak",
      "fallback_behavior": "none",
      "preconditions": "none",
      "platform_coverage": "posix_only",
      "dependency_footprint": "minimal_extra",
      "observability": "none",
      "determinism": "deterministic_when_supported",
      "data_integrity": "fsync/durability",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Backup artifacts may be incomplete or lack durability if fsync fails.",
    "improvement_hooks": ["warn! on fsync failure", "retry symlink once"],
    "related_tests": ["cargo/switchyard/tests/backup_durable_flag.rs"],
    "owner_guess": "fs::backup"
  },
  {
    "id": "cargo/switchyard/src/fs/backup/snapshot.rs:87-114",
    "repo_path": "cargo/switchyard/src/fs/backup/snapshot.rs",
    "start_line": 87,
    "end_line": 114,
    "language": "rust",
    "detection": {"type": "code_pattern", "triggers": ["unlinkat ignored", "dfile.sync_all ignored"]},
    "snippet": "let _ = rustix::fs::unlinkat(&dirfd, bname_c.as_c_str(), AtFlags::empty());\n...\nlet _ = dfile.sync_all();",
    "why_best_effort": "Pre-existing backup cleanup and backup file fsync are attempted but non-fatal if they fail.",
    "effort_dimensions": {
      "error_handling": "nonfatal",
      "guarantee_level": "weak",
      "fallback_behavior": "none",
      "preconditions": "none",
      "platform_coverage": "posix_only",
      "dependency_footprint": "std_only",
      "observability": "none",
      "determinism": "deterministic_when_supported",
      "data_integrity": "fsync/durability",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Potential stale files or unsynced backup under error conditions.",
    "improvement_hooks": ["warn on fsync failure", "retry unlink once"],
    "related_tests": ["cargo/switchyard/tests/backup_durable_flag.rs"],
    "owner_guess": "fs::backup"
  },
  {
    "id": "cargo/switchyard/src/fs/backup/prune.rs:117-129",
    "repo_path": "cargo/switchyard/src/fs/backup/prune.rs",
    "start_line": 117,
    "end_line": 129,
    "language": "rust",
    "detection": {"type": "both", "triggers": ["comment: Best-effort deletions", "let _ = fs::remove_file", "let _ = fsync_parent_dir"]},
    "snippet": "// Best-effort deletions; ignore individual errors so we continue cleaning others\nlet _ = fs::remove_file(&base);\nlet sc = sidecar_path_for_backup(&base);\nlet _ = fs::remove_file(&sc);\nlet _ = fsync_parent_dir(target);",
    "why_best_effort": "Prune tolerates individual deletion/fsync failures to continue pruning others.",
    "effort_dimensions": {
      "error_handling": "nonfatal",
      "guarantee_level": "weak",
      "fallback_behavior": "skip_step",
      "preconditions": "none",
      "platform_coverage": "posix_only",
      "dependency_footprint": "std_only",
      "observability": "none",
      "determinism": "deterministic_when_supported",
      "data_integrity": "fsync/durability",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Some stale backups may remain if deletion fails.",
    "improvement_hooks": ["emit per-file deletion error metrics"],
    "related_tests": ["cargo/switchyard/tests/fs/prune_backups.rs"],
    "owner_guess": "fs::backup"
  },
  {
    "id": "cargo/switchyard/src/fs/restore/engine.rs:112-121",
    "repo_path": "cargo/switchyard/src/fs/restore/engine.rs",
    "start_line": 112,
    "end_line": 121,
    "language": "rust",
    "detection": {"type": "code_pattern", "triggers": ["force_best_effort => Noop", "read_sidecar(...).ok()"]},
    "snippet": "if !opts.force_best_effort { return Err(std::io::Error::new(std::io::ErrorKind::NotFound, \"backup missing\")); }\nreturn Ok((None, None, RestoreAction::Noop));\nlet sc = read_sidecar(&sidecar_path).ok();",
    "why_best_effort": "When configured, restore proceeds without a backup (no-op); sidecar parse errors are ignored.",
    "effort_dimensions": {
      "error_handling": "soft_fail",
      "guarantee_level": "conditional",
      "fallback_behavior": "skip_step",
      "preconditions": "requires_feature",
      "platform_coverage": "portable",
      "dependency_footprint": "std_only",
      "observability": "structured_logs",
      "determinism": "deterministic_when_supported",
      "data_integrity": "snapshot_first",
      "safety_surface": "has_rollback"
    },
    "risk_notes": "Silent acceptance of missing backups can leave system un-restored.",
    "improvement_hooks": ["gate best-effort restore by policy and emit audit warn"],
    "related_tests": ["cargo/switchyard/tests/apply/best_effort_restore_ok.rs"],
    "owner_guess": "fs::restore"
  },
  {
    "id": "cargo/switchyard/src/fs/restore/engine.rs:146-156",
    "repo_path": "cargo/switchyard/src/fs/restore/engine.rs",
    "start_line": 146,
    "end_line": 156,
    "language": "rust",
    "detection": {"type": "code_pattern", "triggers": ["integrity mismatch => Noop when force_best_effort"]},
    "snippet": "if let Some(ref expected) = side.payload_hash {\n    if !integrity::verify_payload_hash_ok(&backup, expected.as_str()) {\n        if opts.force_best_effort { return Ok((backup_opt, Some(side), RestoreAction::Noop)); }\n        return Err(std::io::Error::new(..., \"backup payload hash mismatch\"));\n    }\n}",
    "why_best_effort": "If integrity check fails and best-effort is forced, restoration is skipped instead of failing.",
    "effort_dimensions": {
      "error_handling": "soft_fail",
      "guarantee_level": "conditional",
      "fallback_behavior": "skip_step",
      "preconditions": "requires_feature",
      "platform_coverage": "portable",
      "dependency_footprint": "std_only",
      "observability": "structured_logs",
      "determinism": "deterministic_when_supported",
      "data_integrity": "crc/hash",
      "safety_surface": "has_rollback"
    },
    "risk_notes": "May leave file in degraded state with known integrity mismatch.",
    "improvement_hooks": ["policy option to force failure on mismatch"] ,
    "related_tests": ["cargo/switchyard/tests/apply/error_restore_failed.rs"],
    "owner_guess": "fs::restore"
  },
  {
    "id": "cargo/switchyard/src/fs/restore/steps.rs:26-35",
    "repo_path": "cargo/switchyard/src/fs/restore/steps.rs",
    "start_line": 26,
    "end_line": 35,
    "language": "rust",
    "detection": {"type": "code_pattern", "triggers": ["let _ = std::fs::remove_file", "let _ = fsync_parent_dir"]},
    "snippet": "let _ = std::fs::remove_file(target_path);\n...\nrenameat(&dirfd, old_c.as_c_str(), &dirfd, new_c.as_c_str())?;\nlet _ = fsync_parent_dir(target_path);",
    "why_best_effort": "Legacy rename tolerates failure to remove target and does not fail on fsync errors.",
    "effort_dimensions": {
      "error_handling": "nonfatal",
      "guarantee_level": "weak",
      "fallback_behavior": "none",
      "preconditions": "none",
      "platform_coverage": "posix_only",
      "dependency_footprint": "minimal_extra",
      "observability": "none",
      "determinism": "deterministic_when_supported",
      "data_integrity": "fsync/durability",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Target may linger if removal fails prior to rename.",
    "improvement_hooks": ["log remove error", "bubble fsync errors under strict durability policy"],
    "related_tests": ["cargo/switchyard/tests/fs/restore_invertible_roundtrip.rs"],
    "owner_guess": "fs::restore"
  },
  {
    "id": "cargo/switchyard/src/fs/restore/integrity.rs:7-12",
    "repo_path": "cargo/switchyard/src/fs/restore/integrity.rs",
    "start_line": 7,
    "end_line": 12,
    "language": "rust",
    "detection": {"type": "code_pattern", "triggers": ["Option-based integrity: treat None as OK"]},
    "snippet": "if let Some(actual) = crate::fs::meta::sha256_hex_of(backup) { actual == expected } else { true }",
    "why_best_effort": "Integrity check defers failure when hash cannot be computed, returning true to avoid false negatives.",
    "effort_dimensions": {
      "error_handling": "soft_fail",
      "guarantee_level": "weak",
      "fallback_behavior": "default_value",
      "preconditions": "none",
      "platform_coverage": "portable",
      "dependency_footprint": "std_only",
      "observability": "none",
      "determinism": "deterministic_when_supported",
      "data_integrity": "crc/hash",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Treats unreadable payload as matching, potentially masking corruption.",
    "improvement_hooks": ["emit warn when integrity cannot be computed"],
    "related_tests": ["cargo/switchyard/tests/apply/sidecar_integrity_disabled.rs"],
    "owner_guess": "fs::restore"
  },
  {
    "id": "cargo/switchyard/src/fs/meta.rs:21-27",
    "repo_path": "cargo/switchyard/src/fs/meta.rs",
    "start_line": 21,
    "end_line": 27,
    "language": "rust",
    "detection": {"type": "code_pattern", "triggers": [".ok()? on File::open", ".ok()? on copy"]},
    "snippet": "let mut file = std::fs::File::open(path).ok()?;\nlet mut hasher = Sha256::new();\nstd::io::copy(&mut file, &mut hasher).ok()?;",
    "why_best_effort": "Hash computation returns None on IO errors rather than surfacing an error.",
    "effort_dimensions": {
      "error_handling": "soft_fail",
      "guarantee_level": "weak",
      "fallback_behavior": "default_value",
      "preconditions": "none",
      "platform_coverage": "portable",
      "dependency_footprint": "std_only",
      "observability": "none",
      "determinism": "deterministic_when_supported",
      "data_integrity": "crc/hash",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Callers may assume integrity OK when None is not checked.",
    "improvement_hooks": ["return Result instead of Option"],
    "related_tests": ["cargo/switchyard/tests/apply/sidecar_integrity_disabled.rs"],
    "owner_guess": "fs::meta"
  },
  {
    "id": "cargo/switchyard/src/logging/facts.rs:36-49",
    "repo_path": "cargo/switchyard/src/logging/facts.rs",
    "start_line": 36,
    "end_line": 49,
    "language": "rust",
    "detection": {"type": "code_pattern", "triggers": ["let _ = create_dir_all", "let _ = OpenOptions::open", "let _ = f.write_all"]},
    "snippet": "if let Some(parent) = self.path.parent() { let _ = std::fs::create_dir_all(parent); }\nif let Ok(mut f) = std::fs::OpenOptions::new().create(true).append(true).open(&self.path) {\n    let _ = f.write_all(line.as_bytes());\n    let _ = f.write_all(b\"\\n\");\n}",
    "why_best_effort": "File-backed sink swallows IO errors to avoid impacting primary execution; audit is best-effort.",
    "effort_dimensions": {
      "error_handling": "nonfatal",
      "guarantee_level": "none",
      "fallback_behavior": "none",
      "preconditions": "none",
      "platform_coverage": "portable",
      "dependency_footprint": "std_only",
      "observability": "structured_logs",
      "determinism": "deterministic_when_supported",
      "data_integrity": "no_check",
      "safety_surface": "idempotent"
    },
    "risk_notes": "Loss of audit lines under IO failures.",
    "improvement_hooks": ["count and report dropped audit lines"],
    "related_tests": ["none"],
    "owner_guess": "logging"
  }
]